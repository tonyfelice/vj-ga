

/*

This section sets up the baseline GATC

 */

try{			
    _vj.arrhost = location.hostname.split('.');
    _vj.utmhost = '.' + _vj.arrhost[_vj.arrhost.length-2] + '.' + _vj.arrhost[_vj.arrhost.length-1];
    _gaq.push(
	['_setAccount', _vj.primary]
	,['_setDomainName', _vj.utmhost]
	,['_setAllowLinker', ((_vj._allowDomain) !== 'undefined' && _vj._allowDomain.length > 1)]
	,['_setAllowHash', !((_vj._allowDomain) !== 'undefined' && _vj._allowDomain.length > 1)]
    );
    if(typeof(_vj.secondary) !== 'undefined' && _vj.secondary.length > 0){
	_gaq.push(
	    ['b._setAccount', _vj.secondary]
	    ,['b._setDomainName', _vj.utmhost]
	    ,['b._setAllowLinker', ((_vj._allowDomain) !== 'undefined' && _vj._allowDomain.length > 1)]
	    ,['b._setAllowHash', !((_vj._allowDomain) !== 'undefined' && _vj._allowDomain.length > 1)]
	);
	//_gaq.push(['b.trackPageview']);
    }
} catch(err) { console.log(err); }



/* This section configures 4 of the 5 available Custom Variables.

Originally inspired by Will Critchlow (http://attributiontrackingga.googlecode.com); released under GPLv3;
initially modified 10/10/10 tfelice
12/31/12 [tf]	incorporated new CV4 format (using ^ delim)
		rather than only setting on new visits, setting when CV4 does not match cookie ID
		Pulling utma ID (was using posix)

Because GA is typically a last-touch attribution tool, the first two custom variables are used to store the referrer and landing  page associated with a user's first visit.
The third custom variable stores historical conversion information, and the fourth variable stores a unique identifier for each visitor.
These custom variables will exist for the user until cookies are cleared.  Because the slots are limited, and the storage expectation is for the lifetime of the cookie,
I've iterated them below, along with a mnemonic in parentheses. 
1.	("From")   stores the first touch referrer 
2.	("To")   stores the first touch landing page
3.	("Free" or "E" as in e-comm)   aggregates historical conversion information in 5 parts:
     a.	Total number of conversions for the visitor
     b.	Total aggregate value of all historical conversions
     c.	Milliseconds elapsed between the current conversion event and the previous 
     d.	Time of the current conversion event (posix format)
     e.	Time of the first conversion (posix format)
4.	("For")   stores a unique identifier for each visitor. In no way personally identifiable, this is the user identifier assigned by Google in the __utma cookie, but otherwise unavailable to GA reporting

*/

function _test(cky) {
	var boo = 0;
	var dat = '';
	var jar = document.cookie.split(';');
	cky = cky+"=";
	for (var i=0;i<jar.length;i++){
		while (jar[i].charAt(0)==' ') jar[i] = jar[i].substring(1,jar[i].length);
		if (jar[i].indexOf(cky) == 0){
			boo = 1;
			dat = jar[i].substring(cky.length, jar[i].length);
		}
	}
	return (arguments.length == 2) ? dat : boo;
}
function _crop(s) {
	var sz = 63;
	if (encodeURIComponent(s).substr(sz-2,1) == "%"){
		out = decodeURIComponent(encodeURIComponent(s).substr(0,sz-2));
	} else if (encodeURIComponent(s).substr(sz-1,1) == "%"){
		out = decodeURIComponent(encodeURIComponent(s).substr(0,sz-1));
	} else {
		out = decodeURIComponent(encodeURIComponent(s).substr(0,sz));
	}
	return out;
}
function _getCV(i){
	var cky = '__utmv';
	var ret = _test(cky,1);
	var tmp = false;
	if (_test(cky) === 0){return tmp;}else{
		ret = ret.split('|');
		ret = ret[1].split('^');
		for(j=0; j<ret.length; j++){
			if(ret[j].charAt(0) == i){
				tmp = ret[j].split('=');
			}
		}
		return tmp;		
	}
}
function _getId(){
	var cky = '__utma';
	var ret = _test(cky,1);
	if (_test(cky) === 0){
		return false;
	}else{
		ret = ret.split('.');
		return ret[1];		
	}
}
function _setCV(o){
	try {
		var id = _getId();
		var cv = _getCV(4);
		if (cv == false || cv[2] != id){ // ||cv4 neq id				 		
			o.push(['_setCustomVar', 1, 'r', (document.referrer.length > 0)?_crop(document.referrer.substr(7,document.referrer.length)):'(direct)', 1]);
			o.push(['_setCustomVar', 2, 'l', _crop(window.location.pathname), 1]);
			o.push(['_setCustomVar', 4, 'v', id, 1]);
		}
		o.push(['_setVar'])
	} catch (err) {console.log(err);}
}
function _goal(gaq,nom,val){//count.total.sincelast.timenow.timefirst
	try {
		var cv = _getCV(3);
		var dt = new Date().getTime();
		val = Math.round(val);
		if(cv.length > -1 && cv[1] =='g'){
			cv = cv[2].split('.');
			cv[0]++;
			cv[1]=eval(val)+eval(cv[1]);
			cv[2] = dt - cv[3];
			gaq.push(['_setCustomVar', 3, 'g', cv[0] +'.'+ cv[1] +'.'+ cv[2] +'.'+ dt +'.'+ cv[4], 1]);
		}
		if(!cv){
			gaq.push(['_setCustomVar', 3, 'g', 1 +'.'+ val +'.'+ 0 +'.'+ dt +'.'+ dt, 1]);	
		}
		cv = _getCV(4);
		gaq.push(['_trackEvent', 'auto-goal', nom, cv, val]);
	} catch (err) {console.log(err);}
}
jQuery(document).ready(function(){
	_setCV(_gaq);
});


/*
~*~*~*~*~*~*~*~*~*~*~*~*~*
linkage and event handlers
~*~*~*~*~*~*~*~*~*~*~*~*~*

INTEGRATED 12/12
    social login status (inspired by) http://www.seomoz.org/blog/visitor-social-network-login-status-google-analytics
    CV4 from cookie
    prevent form data
    pagename in clicks and forms 
    event validation (verify all strings)

    
TO DO:
    track ajax and touch
    iframe support
    linkbypost
    allowDomain regex
    non-interaction events
    multiple tracker support
    viewport detect - (inspired by) http://wishfulcode.com/2011/11/02/measuring-viewport-size-with-google-analytics/
    stop x-domain canonicals
    blur/focus tab? (inspired by) http://stackoverflow.com/questions/3648120/is-there-a-way-track-the-focus-on-tab-with-javascript
    Addthis support (inspired by) http://support.addthis.com/customer/portal/articles/381260-google-analytics-integration#.UN-U75G9KSM
    Linkedin? (inspired by) http://www.linkedin.com/js/public-profile/widget-os.js http://scottalanwilliamson.com/
    youtube (inspired by) http://www.lunametrics.com/blog/2012/10/22/automatically-track-youtube-videos-events-google-analytics/
    referrer breadcrumb (inspired by) http://sixrevisions.com/web-development/hacking-google-analytics-ideas-tips-and-tricks/

*/

jQuery(document).ready(function(){
	var thishost = location.hostname;
	var regex = /^http(s)?\:\/\//i;
	var fileregex = /\.(xml|rss|json|gif|jpg|png|pdf|txt|doc|docx|dmg|xls|xlsx|ppt|pptx|swf|wav|wma|mp3|mp4|mpg|mov|msi|exe|ics|vcf|zip|sit|rar|gz)($|[#\?])/i;
	_vj.frmOrder = 1;
	
	//link handler: x-domain, download, and outbound
	jQuery('a').each(function(){
		try{
			var tracker = false; 		
			var thishref = (jQuery(this).attr('href')) ? jQuery(this).attr('href') : 'none';
			var linkflag = false;
			if(thishref != 'none' && thishref.search(regex)>-1 && thishref.indexOf(thishost)==-1){
				if(typeof(_vj._allowDomain) !== 'undefined' && _vj._allowDomain.length > 0){
					for(i=0; i<_vj._allowDomain.length; i++){
						if(thishref.indexOf(_vj._allowDomain[i])>-1){								
							try{
								jQuery(this).click(function(event){
									event.preventDefault();
									tracker = _gaq._getAsyncTracker();	
									this.href = tracker._getLinkerUrl(this.href);
									if (jQuery(this).hasClass('gae_chainwindow') || jQuery(this).attr('target')=='_blank' || jQuery(this).attr('rel')=='external'){  //gae_chainwindow will allow the session to cross into iFrames and new tabs
										window.open(this.href);
									}else{
										window.location = this.href;	
									}										
								});									
							}catch(err){
								console.log('link:' + err + '; ' + this.href + ' getLinkerURL fail');
							}								
							linkflag = true;
						}
					}
				}
				if(!linkflag){
					jQuery(this).click(function(){
						_gaq.push(['_trackPageview', '/outbound/'+this.href.replace(regex, '')]); 
					});
				}	
			}else if(thishref != 'none' && thishref.search(fileregex)>-1 && ((thishref.search(regex)>-1 && thishref.indexOf(thishost)>-1) || (thishref.search(regex)==-1))){
				jQuery(this).click(function(){
					_gaq.push(['_trackPageview', '/download/'+this.href.replace(regex, '')]); 
				});
			}
		} catch(err) {
			console.log('link:' + err + '; ' + this.href + ' not handled');
		}
	});
	
	//linkbypost handler
	if(typeof(_vj._allowDomain) !== 'undefined' && _vj._allowDomain.length > 0){
		jQuery('form').each(function(){
			try{				
				var thisaction = (jQuery(this).attr('action')) ? jQuery(this).attr('action') : 'none';
				if(thisaction != 'none' && thisaction.search(regex)>-1 && thisaction.indexOf(thishost)==-1){
					for(i=0; i<_vj._allowDomain.length; i++){
						if(thisaction.indexOf(_vj._allowDomain[i])>-1){
							jQuery(this).submit(function(){
								_gaq.push(['_linkByPost', this]);
							});
						}
					}							
				}
			} catch(err) {
				console.log('form:' + err + '; ' + this + ' linkByPost fail');
			}
		});
	}
});

// "forms and clicks" event handlers
jQuery(document).ready(function(){
	jQuery('input,select,textarea,button').each(function(){
		try{
			var __fld
			,__frm = jQuery(this).parent('form');
			if(!jQuery(this).hasClass('gae_noevent')  && !__frm.hasClass('gae_noevent')){ //'gae_noevent' class can be set at the form or element levels, and will disable tracking
				__frm = (__frm.attr('id').length > 0) ? __frm.attr('id')+':' : __frm.attr('name')+':';
				__fld = (this.id.length > 0) ? __frm + this.id : __frm + this.name;
				__fld = location.pathname +':'+ __fld;
				jQuery(this).blur(function(){
					_evTrackProxy('forms', __fld.toString(), '', this);
				});						
			}
		} catch(err) {
			console.log('flds:' + err + '; ' + this + ' inspection fail');
		}						
	});		
	jQuery("*").click(function(e){
		try{
			var target = [e.target.nodeName.toLowerCase()];
			var ePos = e.pageX+','+e.pageY;
			target[1] = '';
			target[1] = (target[1] == '' && typeof(jQuery(e.target).attr('id')) !== 'undefined' && jQuery(e.target).attr('id').length > 0) ?  '#' + jQuery(e.target).attr('id') : target[1];
			target[1] = (target[1] == '' && typeof(jQuery(e.target).attr('class')) !== 'undefined' && jQuery(e.target).attr('class').length > 0) ?  '.' + jQuery(e.target).attr('class') : target[1];
			target[1] = (target[1] == '' && typeof(jQuery(e.target).attr('name')) !== 'undefined' && jQuery(e.target).attr('name').length > 0) ?  ':' + jQuery(e.target).attr('name') : target[1];
			target[1] = (target[1] == '' && typeof(jQuery(e.target).attr('title')) !== 'undefined' && jQuery(e.target).attr('title').length > 0) ?  '-' + jQuery(e.target).attr('title') : target[1];
			target[1] = (target[1] == '' && typeof(jQuery(e.target).attr('rel')) !== 'undefined' && jQuery(e.target).attr('rel').length > 0) ?  '=' + jQuery(e.target).attr('rel') : target[1];
			if(typeof(jQuery(e.target).attr('href')) != 'undefined' && jQuery(e.target).attr('href').length > 0){
				target[2] = ' (href=' + jQuery(e.target).attr('href') + ')';
			}
			target = target.toString().replace(/,/g,'');
			target = location.pathname +':'+ target;
			if(!jQuery(e.target).parents().andSelf().hasClass('gae_noclick') && _vj._thisClickEvent != ePos && (typeof(_vj._logClickEvent) === 'undefined' || _vj._logClickEvent == true)){/* look up the chain for .gae_noclick, and only track if false*/
				_evTrackProxy('clicks', target, e.pageX+','+e.pageY);
				_vj._thisClickEvent = ePos;
			}
			//test for the presence of a virtual pageview request
			try{
				if(jQuery(e.target).hasClass('gae_virtualpage') && _vj._thisClickVirtual != target){
					_gaq.push(['_trackPageview', '/virtualpage/' + encodeURI(target) ]);
					_vj._thisClickVirtual = target;
				}
			} catch(err) {
				console.log('click:' + err + '; ' + this + ' virtual pv fail');
			}	
		} catch(err) {
			console.log('click:' + err);
		}	
	});
	try{
		_vj.paramsLogged = '';			
		if(typeof(_vj._trackParameters) !== 'undefined' && _vj._trackParameters.length > 0 && window.location.search.length > 0){
			for(i=0; i<_vj._trackParameters.length; i++){
				if(typeof(jQuery.querystring[_vj._trackParameters[i]]) !== 'undefined' && _vj.paramsLogged.indexOf(_vj._trackParameters[i])<0 ){								
					_evTrackProxy('params', _vj._trackParameters[i], jQuery.querystring[_vj._trackParameters[i]]);
					_vj.paramsLogged += _vj._trackParameters[i] + ',';
				}
			}
		}
	}catch(err){
		console.log('param:' + err);
	}
});

// event proxy function to catch from "forms and clicks" - also exposed to flash, so please do not change fn name
function _evTrackProxy(cat, action, label, el){
	var tmp = '';
	var regex = '';
	try{
		if(typeof(el) !== 'undefined'){
			label = ''+_vj.frmOrder+'';
			_vj.frmOrder++;
		}
		_gaq.push(['_trackEvent', cat, action, label]);
	} catch(err) {
		console.log('eventProxy:' + err);
	}
}

// jQuery qs plugin
(function($) {
    $.querystring = (function(qstr) {
	if (qstr == "") return {};
	var result = {};
	for (var i = 0; i < qstr.length; ++i){
	    var key=qstr[i].split('=');
	    result[key[0]] = decodeURIComponent(key[1].replace(/\+/g, " "));
	}
	return result;
    })(window.location.search.substr(1).split('&'))
})(jQuery);



/* Viewport detection

fires event on initial load and resize events, as well as height/width flipflop indicating device reorientation

*/

//send to GA window viewport size on inital load and when resized as non-interactive events
jQuery(function() {
    //init
    var win = {
	width:0
	,height:0
	,preW:0
	,preH:0
	,layout:0
	,maxW:0
    };
    
    //track viewport dimensions
    function logViewport(state){
	win.width = jQuery(window).width();
	win.height = jQuery(window).height();
	win.layout = (win.width > win.height) ? 'landscape' : 'portrait';
	win.maxW = window.screen.availWidth;
	if(state != 'initial' && (win.height == win.preW && win.width == win.preH)){
	    state = 'flip';
	}
	
	if(typeof(_vj.debug) !== 'undefined' && _vj.debug == true){
	    console.log(state);
	    console.log(win.width);
	    console.log(win.height);
	    console.log(win.layout);
	    console.log(win.maxW);
	}else{
	    _gaq.push(['_trackEvent', 'viewport', state +' layout', win.layout, 0, true]);
	    _gaq.push(['_trackEvent', 'viewport', state +' width', win.width, 0, true]);
	    _gaq.push(['_trackEvent', 'viewport', state +' height', win.height, 0, true]);
	    _gaq.push(['_trackEvent', 'viewport', state +' avail width', win.maxW, 0, true]);
	}
	
	//reset the placeholder vars
	win.preW = win.width;
	win.preH = win.height;
    }
    logViewport('initial');
    
    //resize listener
    var tmpTimer;
    jQuery(window).resize(function(){
	clearTimeout(tmpTimer);
	tmpTimer = setTimeout(function(){
	    logViewport('resize');
	}, 500);  //note: this timer is dormant UNLESS there's a resize event in play
    });
});

/* Scroll detection

based on work by
Justin Cutroni
Nick Mihailovski
Thomas Baekdal
Avinash Kaushik
Joost de Valk
Eivind Savio
 
http://cutroni.com/blog/2012/02/21/advanced-content-tracking-with-google-analytics-part-1/

*/


jQuery(function() {
    // Debug flag
    var debugMode = false;

    // Default time delay before checking location
    var callBackTime = 100;

    // # px before tracking a reader
    var readerLocation = 150;
    
    // Set some flags for tracking & execution
    var timer = 0;
    var scroller = false;
    var endContent = false;
    var didComplete = false;

    // Set some time variables to calculate reading time
    var startTime = new Date();
    var beginning = startTime.getTime();
    var totalTime = 0;

    // Track the aticle load?
    //_gaq.push(['_trackEvent', 'scrolling', 'loaded', '', 0, true]);
    
    if(typeof(_vj.debug) !== 'undefined' && _vj.debug == true){
	debugMode = true;
    }
    
    //process the timer
    function doTime(a, b){
	return (Math.round((a - b) / 100)/10).toString() + ' sec';
    }

    // Check the location and track user
    function trackLocation() {
        bottom = jQuery(window).height() + jQuery(window).scrollTop();
        height = jQuery(document).height();

        // If user starts to scroll send an event
        if (bottom > readerLocation && !scroller) {
            currentTime = new Date();
            scrollStart = currentTime.getTime();
            timeToScroll = doTime(scrollStart, beginning);
            if (!debugMode) {
                _gaq.push(['_trackEvent', 'scrolling', 'scroll started', timeToScroll ]);
            } else {
                console.log('started reading ' + timeToScroll);
            }
            scroller = true;
        }

        // If user has hit the bottom of the content send an event
        /*if (bottom >= jQuery('.entry-content').scrollTop() + jQuery('.entry-content').innerHeight() && !endContent) {
            currentTime = new Date();
            contentScrollEnd = currentTime.getTime();
            timeToContentEnd = doTime(contentScrollEnd, scrollStart);
            if (!debugMode) {
                _gaq.push(['_trackEvent', 'scrolling', 'ContentBottom', '', timeToContentEnd]);
            } else {
                console.log('end content section '+timeToContentEnd);
            }
            endContent = true;
        }*/

        // If user has hit the bottom of page send an event
        if (bottom >= height && !didComplete) {
            currentTime = new Date();
            end = currentTime.getTime();
            totalTime = doTime(end, scrollStart);
            if (!debugMode) {
                if (totalTime < 60) {
                    //_gaq.push(['_setCustomVar', 5, 'ReaderType', 'Scanner', 2]);
		    _gaq.push(['_trackEvent', 'engagement', location.pathname+' : scanner', totalTime ]);
                } else {
                    //_gaq.push(['_setCustomVar', 5, 'ReaderType', 'Reader', 2]);
		    _gaq.push(['_trackEvent', 'engagement', location.pathname+' : reader', totalTime ]);
                }
                _gaq.push(['_trackEvent', 'scrolling', 'page bottom', totalTime ]);
            } else {
                console.log('bottom of page '+totalTime);
            }
            didComplete = true;
        }
	
	// If user returns to top send an event
        if (jQuery(window).scrollTop() == 0 && scroller) {
            currentTime = new Date();
            end = currentTime.getTime();
            timeToScroll = doTime(end, scrollStart);
            if (!debugMode) {
                _gaq.push(['_trackEvent', 'scrolling', 'back to top', timeToScroll ]);
            } else {
                console.log('back to top ' + timeToScroll);
            }
            scroller = true;
	    didComplete = false;
        }

        
    }

    // Track the scrolling and track location
    jQuery(window).scroll(function() {
        if (timer) {
            clearTimeout(timer);
        }
        // Use a buffer so we don't call trackLocation too often.
        timer = setTimeout(trackLocation, callBackTime);
    });
});

// should be a logical loader for plugins including social, right now it's hardcoded to run social

(function (window, undefined) {
	//handler for loading scripts
	var script
	,loader = function(src){  
	    var doc = window.document
	    ,tag = 'script'
	    ,g=doc.createElement(tag)
	    ,s=doc.getElementsByTagName(tag)[0];
	    g.src=src;
	    s.parentNode.insertBefore(g,s);
	}
	,scripts = ['social']
	,loadScr = function () {  
	    //loop the scripts json and handle accordingly
	    for (var i = 0; i < scripts.length; i++) {
		script = scripts[i];
		loadScr('http://vj-ga.googlecode.com/svn/trunk/vj_ga_'+script+'.js');
	    }
	};
	window.loadScr = loadScr;
}(window));

loadScr();

testSocial({
    beaconName: 'app id from service'//example// ,facebook: '1234567890'
    ,callback: logSocial
});
function logSocial(key, val){ //this is just a stubbed data handler,. live would track event
    if(typeof(_vj.debug) !== 'undefined' && _vj.debug == true){
	console.log(key +' '+ val);
    }else{
	_gaq.push(['_trackEvent', 'social network detection', key, value, 0, true]);
    }
}





